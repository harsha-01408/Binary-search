FCDC - Factorial Modulo
#number-theory

You are given two integers a, b. Find the number of integers i (i ≥ 1) for which i! is divisible by a but not divisible by b. If i! is divisible by both a and b, then you should not count that i.

Input
One line containing two integers a and b.

Output
Output a single line with the result.

Constraints
1 ≤ a ≤ b ≤ 10^7

Example
Input:
2 3

Output:
1

Explanation
2! is the only factorial which is divisible by 2 and not divisible by 3.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Determine Maximum Total Data Flow

You are given an array bandwidth of length n, where bandwidth[i] represents the bandwidth of the i-th processing node.

You also have an integer streamCount, which represents the exact number of data channels that must be opened.

Each data channel connects two (not necessarily distinct) nodes:
- One node is considered the main node.
- The other node is considered the secondary node.

Thus, each channel corresponds to an ordered pair of indices (i, j), where:
- 0 ≤ i, j < n

The data flow of a single channel (i, j) is defined as:
    bandwidth[i] + bandwidth[j]

Constraints:
- You may use each ordered pair (i, j) at most once.
- (i, j) and (j, i) are considered different pairs, and both may be used if desired.
- Pairs where i = j are also allowed.

Your task:
Choose exactly streamCount distinct ordered pairs (i, j) so that the sum of their data flows
    Σ (bandwidth[i] + bandwidth[j])
is as large as possible.

Return this maximum possible total data flow as a long integer.

Function signature (C++):
    long determineMaxDataFlow(vector<int> bandwidth, long streamCount);


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Q. Maximum Pipeline Throughput

A data processing pipeline consists of n services connected in series.
The output of service i becomes the input of service i+1.

Each service i has an initial throughput (messages per minute):
    throughput[i]

Each service can be scaled independently. Scaling up service i one time costs:
    scalingCost[i]

If a service is scaled up x times, its new throughput becomes:
    throughput[i] * (1 + x)

Since all services are in a chain, the effective throughput of the entire
pipeline is the minimum throughput among all services:
    pipelineThroughput = min( newThroughput[0], ..., newThroughput[n-1] )

You are given:
    throughput[] : size n, base throughput of each service
    scalingCost[]: size n, cost to scale each service once
    budget       : total money available

Task:
Choose how many times to scale each service (x0, x1, ..., x_{n-1},
each an integer >= 0) so that the total cost

    sum( x_i * scalingCost[i] ) <= budget

and the resulting pipeline throughput (minimum of all new throughputs)
is maximized.

Return that maximum achievable pipeline throughput as a long integer.

Constraints:
    1 <= n <= 100000
    1 <= throughput[i] <= 1e7
    1 <= scalingCost[i] <= 200
    1 <= budget <= 1e9
    Maximum throughput achievable <= 1e9

Examples:

1) 
n = 3
throughput = [3, 2, 5]
scalingCost = [2, 5, 10]
budget = 28
Output: 6

2)
throughput = [4, 2, 7]
scalingCost = [3, 5, 6]
budget = 32

One optimal allocation:
- Scale service 0 by 2 -> new throughput = 4 * 3 = 12, cost = 6
- Scale service 1 by 4 -> new throughput = 2 * 5 = 10, cost = 20
- Scale service 2 by 1 -> new throughput = 7 * 2 = 14, cost = 6
Total cost = 6 + 20 + 6 = 32 (within budget)
Pipeline throughput = min(12, 10, 14) = 10

Output: 10

Function to implement:
    long getMaximumThroughput(int throughput[], int scalingCost[], int budget)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

A process tree is defined as follows:

- Process 1 is the root.
- For every process i (i ≥ 1), process i spawns exactly i child processes.
- New processes are assigned the next available integer IDs in increasing order (2, 3, 4, ...).

For example:
1 spawns: 2
2 spawns: 3, 4
3 spawns: 5, 6, 7
4 spawns: 8, 9, 10, 11
...

Given an integer processNumber (processNumber ≥ 2), find and return the ID of the
parent process that spawned processNumber.

Write a function:
  int findParent(int processNumber)
that returns the parent of processNumber.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

A teacher assigns random positive integers to n students, represented in an
array arr, to pair students for a project. Two students can be paired if the
product of the numbers assigned to them is NOT a perfect square. Each student
can be part of at most one pair.

You are allowed to change the numbers assigned to at most k students. Each
changed number can be replaced with any positive integer.

Find the maximum number of valid pairs that can be formed after making at most
k changes.

Example:
arr = [4, 12, 20, 5, 20, 5, 45]
k = 1

In this example, n = 7.

• 4 and 5 can be paired since their product 20 is not a perfect square.
• 12 and 20 can be paired since their product 240 is not a perfect square.
• By changing one value (for example, changing 20 to 11), 11 and 5 can be paired
  since their product 55 is not a perfect square.

Thus, the maximum number of valid pairs that can be formed is 3.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
