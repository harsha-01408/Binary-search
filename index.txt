FCDC - Factorial Modulo
#number-theory

You are given two integers a, b. Find the number of integers i (i ≥ 1) for which i! is divisible by a but not divisible by b. If i! is divisible by both a and b, then you should not count that i.

Input
One line containing two integers a and b.

Output
Output a single line with the result.

Constraints
1 ≤ a ≤ b ≤ 10^7

Example
Input:
2 3

Output:
1

Explanation
2! is the only factorial which is divisible by 2 and not divisible by 3.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Determine Maximum Total Data Flow

You are given an array bandwidth of length n, where bandwidth[i] represents the bandwidth of the i-th processing node.

You also have an integer streamCount, which represents the exact number of data channels that must be opened.

Each data channel connects two (not necessarily distinct) nodes:
- One node is considered the main node.
- The other node is considered the secondary node.

Thus, each channel corresponds to an ordered pair of indices (i, j), where:
- 0 ≤ i, j < n

The data flow of a single channel (i, j) is defined as:
    bandwidth[i] + bandwidth[j]

Constraints:
- You may use each ordered pair (i, j) at most once.
- (i, j) and (j, i) are considered different pairs, and both may be used if desired.
- Pairs where i = j are also allowed.

Your task:
Choose exactly streamCount distinct ordered pairs (i, j) so that the sum of their data flows
    Σ (bandwidth[i] + bandwidth[j])
is as large as possible.

Return this maximum possible total data flow as a long integer.

Function signature (C++):
    long determineMaxDataFlow(vector<int> bandwidth, long streamCount);


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Q. Maximum Pipeline Throughput

A data processing pipeline consists of n services connected in series.
The output of service i becomes the input of service i+1.

Each service i has an initial throughput (messages per minute):
    throughput[i]

Each service can be scaled independently. Scaling up service i one time costs:
    scalingCost[i]

If a service is scaled up x times, its new throughput becomes:
    throughput[i] * (1 + x)

Since all services are in a chain, the effective throughput of the entire
pipeline is the minimum throughput among all services:
    pipelineThroughput = min( newThroughput[0], ..., newThroughput[n-1] )

You are given:
    throughput[] : size n, base throughput of each service
    scalingCost[]: size n, cost to scale each service once
    budget       : total money available

Task:
Choose how many times to scale each service (x0, x1, ..., x_{n-1},
each an integer >= 0) so that the total cost

    sum( x_i * scalingCost[i] ) <= budget

and the resulting pipeline throughput (minimum of all new throughputs)
is maximized.

Return that maximum achievable pipeline throughput as a long integer.

Constraints:
    1 <= n <= 100000
    1 <= throughput[i] <= 1e7
    1 <= scalingCost[i] <= 200
    1 <= budget <= 1e9
    Maximum throughput achievable <= 1e9

Examples:

1) 
n = 3
throughput = [3, 2, 5]
scalingCost = [2, 5, 10]
budget = 28
Output: 6

2)
throughput = [4, 2, 7]
scalingCost = [3, 5, 6]
budget = 32

One optimal allocation:
- Scale service 0 by 2 -> new throughput = 4 * 3 = 12, cost = 6
- Scale service 1 by 4 -> new throughput = 2 * 5 = 10, cost = 20
- Scale service 2 by 1 -> new throughput = 7 * 2 = 14, cost = 6
Total cost = 6 + 20 + 6 = 32 (within budget)
Pipeline throughput = min(12, 10, 14) = 10

Output: 10

Function to implement:
    long getMaximumThroughput(int throughput[], int scalingCost[], int budget)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

A process tree is defined as follows:

- Process 1 is the root.
- For every process i (i ≥ 1), process i spawns exactly i child processes.
- New processes are assigned the next available integer IDs in increasing order (2, 3, 4, ...).

For example:
1 spawns: 2
2 spawns: 3, 4
3 spawns: 5, 6, 7
4 spawns: 8, 9, 10, 11
...

Given an integer processNumber (processNumber ≥ 2), find and return the ID of the
parent process that spawned processNumber.

Write a function:
  int findParent(int processNumber)
that returns the parent of processNumber.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

A teacher assigns random positive integers to n students, represented in an
array arr, to pair students for a project. Two students can be paired if the
product of the numbers assigned to them is NOT a perfect square. Each student
can be part of at most one pair.

You are allowed to change the numbers assigned to at most k students. Each
changed number can be replaced with any positive integer.

Find the maximum number of valid pairs that can be formed after making at most
k changes.

Example:
arr = [4, 12, 20, 5, 20, 5, 45]
k = 1

In this example, n = 7.

• 4 and 5 can be paired since their product 20 is not a perfect square.
• 12 and 20 can be paired since their product 240 is not a perfect square.
• By changing one value (for example, changing 20 to 11), 11 and 5 can be paired
  since their product 55 is not a perfect square.

Thus, the maximum number of valid pairs that can be formed is 3.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

Amazon wants to distribute parcels among its delivery agents as evenly as possible.
There are n delivery agents, and each agent i initially has parcels[i] parcels.
In addition, there are extra_parcels parcels that must be assigned to the agents.

Distribute the extra parcels among the agents so that the maximum number of parcels
assigned to any single agent is as small as possible.

Given the integer array parcels and the integer extra_parcels, determine the minimum
possible value of the maximum number of parcels any agent will have after the
distribution.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Question: Maximizing Tool Usage Value

You are given an array remainingUses, where each element represents how
many times a particular developer tool can still be used.

You also have an integer m, representing the number of developers.
Each developer can use exactly one tool, and each tool use works as follows:
- When a tool is used, it gives value equal to its current remaining uses
- After being used, that tool’s remaining uses decrease by 1

Your task is to assign exactly m tool uses (one per developer) in such a way
that the total value gained is maximized.

You may choose the same tool multiple times, as long as it still has
remaining uses left.

Return the maximum total value that can be obtained after m uses.

Goal:
- Always choose tool usages optimally so that higher remaining-use tools
  contribute more value.

Function to implement:
maximizeToolValue(remainingUses, m)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem 

You are given n developers and n projects.

Input data:
- time[i]: the time required by developer i to write one program
- programs[j]: the number of programs in project j

Assignment rules:
- Each developer must be assigned to exactly one project.
- Each project must be assigned to exactly one developer.
- If developer i is assigned project j, the time to complete that project is:
  
    programs[j] × time[i]

Overall completion time:
- All projects run in parallel.
- The total finishing time is the maximum completion time among all assigned developer–project pairs.

Special operation: Workshops
- You may run at most k workshops before assigning projects.
- Each workshop can be applied to any one developer.
- Each workshop reduces that developer’s time[i] by exactly 1.
- Workshops can be distributed arbitrarily among developers.

Goal:
- Distribute up to k workshops across developers.
- Assign developers to projects optimally.
- Minimize the overall completion time (i.e., the maximum value of programs[j] × time[i] after workshops and assignment).

In short:
Use up to k reductions on developer speeds and match developers to projects so that the slowest project finishes as early as possible.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You have a tank with capacity C litres. N people come in a line, and each person wants to trade exactly 1 litre:

- If A[i] = 1, they want to add 1 litre to the tank. This succeeds only if the tank is not full.
  If the tank is already at level C, the action fails and counts as a disturbance.

- If A[i] = -1, they want to remove 1 litre from the tank. This succeeds only if the tank is not empty.
  If the tank is already at level 0, the action fails and counts as a disturbance.

Before the line starts, you can choose the initial tank level X where 0 <= X <= C.

Task: Choose X to minimize the total number of disturbances.
If multiple X give the same minimum disturbances, output the smallest such X.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given n segments on a number line. For each segment [a_i, b_i], choose one
point p_i such that a_i ≤ p_i ≤ b_i.

After choosing one point from every segment, consider the distances between all
pairs of chosen points. Let D be the smallest of these distances.

Your task is to choose the points so that D is as large as possible.

Input:
- n: the number of segments
- intervals: an array of n pairs [a_i, b_i], where 0 ≤ a_i ≤ b_i ≤ 10^14

Output:
- The maximum possible value of D

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

There are n tasks, and each task needs a certain amount of work to be completed.

Work is done in rounds. In every round, you pick one task to get extra attention.
That chosen task makes x units of progress, while all other unfinished tasks make
only y units of progress (with y smaller than x).

Tasks are removed as soon as their required work is done.

You can choose a different task to prioritize in each round.

Find the smallest number of rounds needed to finish all tasks.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
